import { useState, useCallback, useEffect, useRef } from 'react';
import CodeEditor from './CodeEditor';
import { CheckCircle, XCircle, RotateCcw, Play, Plus, Trash2, Link, Clock } from 'lucide-react';
import { toast } from 'sonner';
import ApiService from '../services/api';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';

interface TestCase {
  id: string;
  input: string;
  expectedOutput: string;
  result?: 'pending' | 'pass' | 'fail';
  actualOutput?: string;
}

const PracticeSession = () => {
  const [code, setCode] = useState('');
  const [language, setLanguage] = useState('cpp');
  const [problemLink, setProblemLink] = useState('');
  const [testCases, setTestCases] = useState<TestCase[]>([
    { id: '1', input: '', expectedOutput: '' }
  ]);
  const [sessionStarted, setSessionStarted] = useState(false);
  const [sessionTimer, setSessionTimer] = useState(30); // minutes
  const [currentTestCase, setCurrentTestCase] = useState<TestCase | null>(null);
  const [showComparison, setShowComparison] = useState(false);
  const [isExecuting, setIsExecuting] = useState(false);
  const abortControllerRef = useRef<AbortController | null>(null);

  // New state for enhanced CodeEditor
  const [testInput, setTestInput] = useState('');
  const [testOutput, setTestOutput] = useState('');
  const [consoleOutput, setConsoleOutput] = useState('');
  const [executionTime, setExecutionTime] = useState<number | undefined>();
  const [memoryUsage, setMemoryUsage] = useState<number | undefined>();
  const [testResults, setTestResults] = useState<Array<{ passed: boolean; input: string; expected: string; actual: string }>>([]);

  // Load saved state on component mount
  useEffect(() => {
    try {
      const savedCode = localStorage.getItem('practice-session-code');
      const savedLanguage = localStorage.getItem('practice-session-language');
      const savedProblemLink = localStorage.getItem('practice-session-problem-link');
      const savedTestCases = localStorage.getItem('practice-session-test-cases');
      const savedSessionStarted = localStorage.getItem('practice-session-started');
      const savedCurrentTestCase = localStorage.getItem('practice-session-current-test-case');

      let hasSavedData = false;
      if (savedCode) {
        setCode(savedCode);
        hasSavedData = true;
      }
      if (savedLanguage) setLanguage(savedLanguage);
      if (savedProblemLink) setProblemLink(savedProblemLink);
      if (savedTestCases) {
        try {
          const parsed = JSON.parse(savedTestCases);
          setTestCases(parsed);
        } catch (e) {
          console.warn('Failed to parse saved test cases:', e);
        }
      }
      if (savedSessionStarted) {
        const isStarted = savedSessionStarted === 'true';
        // Only restore session if we have valid data
        if (isStarted && savedProblemLink && savedTestCases) {
          try {
            const parsedTestCases = JSON.parse(savedTestCases);
            const hasValidTestCases = Array.isArray(parsedTestCases) && 
              parsedTestCases.length > 0 && 
              parsedTestCases.every(tc => tc.input?.trim() && tc.expectedOutput?.trim() && tc.id);
            
            if (hasValidTestCases) {
              setTestCases(parsedTestCases);
              setSessionStarted(true);
              
              // Try to restore currentTestCase
              if (savedCurrentTestCase) {
                try {
                  const parsedCurrent = JSON.parse(savedCurrentTestCase);
                  if (parsedCurrent && typeof parsedCurrent === 'object' && parsedCurrent.id && 
                      parsedTestCases.some(tc => tc.id === parsedCurrent.id)) {
                    setCurrentTestCase(parsedCurrent);
                  } else {
                    setCurrentTestCase(parsedTestCases[0]);
                  }
                } catch (e) {
                  console.warn('Failed to parse saved current test case:', e);
                  setCurrentTestCase(parsedTestCases[0]);
                }
              } else {
                setCurrentTestCase(parsedTestCases[0]);
              }
            } else {
              // Invalid session data, reset to setup mode
              setSessionStarted(false);
              localStorage.removeItem('practice-session-started');
            }
        } catch {
          // Invalid test cases data, reset to setup mode
          setSessionStarted(false);
          localStorage.removeItem('practice-session-started');
        }
        } else {
          setSessionStarted(false);
        }
      }

      if (hasSavedData) {
        toast.success('Previous practice session restored!');
      }
    } catch (error) {
      console.warn('Failed to load practice session state:', error);
    }
  }, []);

  // Save state to localStorage whenever it changes
  useEffect(() => {
    try {
      localStorage.setItem('practice-session-code', code);
    } catch (error) {
      console.warn('Failed to save code to localStorage:', error);
    }
  }, [code]);

  useEffect(() => {
    try {
      localStorage.setItem('practice-session-language', language);
    } catch (error) {
      console.warn('Failed to save language to localStorage:', error);
    }
  }, [language]);

  useEffect(() => {
    try {
      localStorage.setItem('practice-session-problem-link', problemLink);
    } catch (error) {
      console.warn('Failed to save problem link to localStorage:', error);
    }
  }, [problemLink]);

  useEffect(() => {
    try {
      localStorage.setItem('practice-session-test-cases', JSON.stringify(testCases));
    } catch (error) {
      console.warn('Failed to save test cases to localStorage:', error);
    }
  }, [testCases]);

  useEffect(() => {
    try {
      localStorage.setItem('practice-session-started', sessionStarted.toString());
    } catch (error) {
      console.warn('Failed to save session started state to localStorage:', error);
    }
  }, [sessionStarted]);

  useEffect(() => {
    try {
      localStorage.setItem('practice-session-current-test-case', JSON.stringify(currentTestCase));
    } catch (error) {
      console.warn('Failed to save current test case to localStorage:', error);
    }
  }, [currentTestCase]);

  const handleCodeChange = useCallback((value: string | undefined) => {
    setCode(value || '');
  }, []);

  // Test case management functions
  const addTestCase = useCallback(() => {
    const newId = (testCases.length + 1).toString();
    setTestCases(prev => [...prev, { id: newId, input: '', expectedOutput: '' }]);
  }, [testCases.length]);

  const removeTestCase = useCallback((id: string) => {
    if (testCases.length > 1) {
      setTestCases(prev => prev.filter(tc => tc.id !== id));
    }
  }, [testCases.length]);

  const updateTestCase = useCallback((id: string, field: 'input' | 'expectedOutput', value: string) => {
    setTestCases(prev => prev.map(tc =>
      tc.id === id ? { ...tc, [field]: value } : tc
    ));
  }, []);

  const startSession = useCallback(() => {
    if (!problemLink.trim()) {
      toast.error('Please enter a problem link');
      return;
    }
    if (testCases.some(tc => !tc.input.trim() || !tc.expectedOutput.trim())) {
      toast.error('Please fill in all test cases');
      return;
    }

    setSessionStarted(true);
    setCurrentTestCase(testCases[0]);
    toast.success('Practice session started!');
  }, [problemLink, testCases]);

  const runTestCase = useCallback(async (testCase: TestCase) => {
    if (!code.trim()) {
      toast.error('Please enter some code to run');
      return;
    }

    setIsExecuting(true);
    setShowComparison(false);
    abortControllerRef.current = new AbortController();

    try {
      const startTime = Date.now();
      const result = await ApiService.executeCppCode(code, testCase.input, abortControllerRef.current.signal);
      const endTime = Date.now();
      const execTime = endTime - startTime;

      const normalizedActual = result.output.trim();
      const normalizedExpected = testCase.expectedOutput.trim();
      const passed = normalizedActual === normalizedExpected;

      // Update test case result
      setTestCases(prev => prev.map(tc =>
        tc.id === testCase.id
          ? { ...tc, result: passed ? 'pass' : 'fail', actualOutput: result.output }
          : tc
      ));

      // Update CodeEditor state
      setConsoleOutput(result.output || 'No output');
      setExecutionTime(execTime);
      setMemoryUsage(Math.random() * 50 + 10); // Mock memory usage for now
      setTestResults([{
        passed,
        input: testCase.input,
        expected: testCase.expectedOutput,
        actual: result.output
      }]);

      if (passed) {
        toast.success(`Test case ${testCase.id} passed! âœ…`);
      } else {
        toast.error(`Test case ${testCase.id} failed! âŒ`);
      }

      return passed;
    } catch (error) {
      setTestCases(prev => prev.map(tc =>
        tc.id === testCase.id
          ? { ...tc, result: 'fail', actualOutput: 'Execution failed' }
          : tc
      ));

      // Update CodeEditor state on error
      setConsoleOutput('Execution failed');
      setExecutionTime(undefined);
      setMemoryUsage(undefined);
      setTestResults([{
        passed: false,
        input: testCase.input,
        expected: testCase.expectedOutput,
        actual: 'Execution failed'
      }]);

      if (error instanceof Error && error.name === 'AbortError') {
        toast.info('Execution stopped');
      } else {
        toast.error(`Test case ${testCase.id} failed - execution error`);
      }
      return false;
    } finally {
      setIsExecuting(false);
      abortControllerRef.current = null;
    }
  }, [code]);

  const runAllTestCases = useCallback(async () => {
    for (const testCase of testCases) {
      await runTestCase(testCase);
      // Small delay between test cases
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }, [testCases, runTestCase]);

  const handleRunCode = useCallback(async () => {
    if (!currentTestCase) return;

    await runTestCase(currentTestCase);
  }, [currentTestCase, runTestCase]);

  const handleResetCode = useCallback(() => {
    setCode('');
  }, []);

  const handleResetSession = useCallback(() => {
    setCode('');
    setLanguage('cpp');
    setProblemLink('');
    setTestCases([{ id: '1', input: '', expectedOutput: '' }]);
    setSessionStarted(false);
    setSessionTimer(30);
    setCurrentTestCase(null);
    setShowComparison(false);
    setIsExecuting(false);

    // Reset new CodeEditor state
    setTestInput('');
    setTestOutput('');
    setConsoleOutput('');
    setExecutionTime(undefined);
    setMemoryUsage(undefined);
    setTestResults([]);

    // Clear localStorage
    try {
      localStorage.removeItem('practice-session-code');
      localStorage.removeItem('practice-session-language');
      localStorage.removeItem('practice-session-problem-link');
      localStorage.removeItem('practice-session-test-cases');
      localStorage.removeItem('practice-session-started');
      localStorage.removeItem('practice-session-current-test-case');
      toast.success('Practice session reset!');
    } catch (error) {
      console.warn('Failed to clear localStorage:', error);
      toast.success('Session reset (localStorage clear failed)');
    }
  }, []);

  const handleCopyCode = useCallback(async () => {
    if (!code.trim()) {
      toast.error('No code to copy');
      return;
    }

    try {
      await navigator.clipboard.writeText(code);
      toast.success('Code copied to clipboard! ðŸ“‹');
    } catch (error) {
      toast.error('Failed to copy code to clipboard');
      console.error('Clipboard error:', error);
    }
  }, [code]);

  const handleStopExecution = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      setIsExecuting(false);
      toast.info('Execution stopped');
    }
  }, []);

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold pb-2">Practice Session</h1>
          <p className="text-muted-foreground">
            {sessionStarted ? 'Solve the problem and test your code' : 'Set up your practice session'}
          </p>
        </div>
        <Button variant="outline" size="sm" onClick={handleResetSession} className="gap-2">
          <RotateCcw className="w-4 h-4" />
          Reset Session
        </Button>
      </div>

      {!sessionStarted ? (
        /* Setup Phase */
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Problem Setup */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Link className="h-5 w-5" />
                Problem Setup
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label htmlFor="problem-link">Problem Link</Label>
                <Input
                  id="problem-link"
                  placeholder="https://leetcode.com/problems/..."
                  value={problemLink}
                  onChange={(e) => setProblemLink(e.target.value)}
                />
              </div>

              <div>
                <Label>Session Timer (minutes)</Label>
                <Input
                  type="number"
                  min="1"
                  max="300"
                  value={sessionTimer}
                  onChange={(e) => setSessionTimer(Math.max(1, parseInt(e.target.value) || 30))}
                  className="w-32"
                />
              </div>
            </CardContent>
          </Card>

          {/* Test Cases Setup */}
          <Card>
            <CardHeader>
              <CardTitle>Test Cases</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {testCases.map((testCase, index) => (
                <div key={testCase.id} className="border rounded p-4 space-y-3">
                  <div className="flex items-center justify-between">
                    <Label className="font-medium">Test Case {index + 1}</Label>
                    {testCases.length > 1 && (
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => removeTestCase(testCase.id)}
                        className="h-8 w-8 p-0"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    )}
                  </div>

                  <div>
                    <Label className="text-sm">Input</Label>
                    <Textarea
                      placeholder="Enter test input..."
                      value={testCase.input}
                      onChange={(e) => updateTestCase(testCase.id, 'input', e.target.value)}
                      className="min-h-[60px] font-mono text-sm"
                    />
                  </div>

                  <div>
                    <Label className="text-sm">Expected Output</Label>
                    <Textarea
                      placeholder="Enter expected output..."
                      value={testCase.expectedOutput}
                      onChange={(e) => updateTestCase(testCase.id, 'expectedOutput', e.target.value)}
                      className="min-h-[60px] font-mono text-sm"
                    />
                  </div>
                </div>
              ))}

              <Button onClick={addTestCase} variant="outline" className="w-full gap-2">
                <Plus className="h-4 w-4" />
                Add Test Case
              </Button>
            </CardContent>
          </Card>

          {/* Start Session Button */}
          <div className="lg:col-span-2 flex justify-center">
            <Button onClick={startSession} size="lg" className="gap-2 px-8 py-3">
              <Play className="h-5 w-5" />
              Start Session
            </Button>
          </div>

          {/* Code Editor Setup */}
          <div className="lg:col-span-2">
            <CodeEditor
              value={code}
              onChange={handleCodeChange}
              language={language}
              onLanguageChange={setLanguage}
              onReset={handleResetCode}
              onCopy={handleCopyCode}
              height="400px"
              testInput={testInput}
              onTestInputChange={setTestInput}
              testOutput={testOutput}
              consoleOutput={consoleOutput}
              executionTime={executionTime}
              memoryUsage={memoryUsage}
              testResults={testResults}
            />
          </div>
        </div>
      ) : (
        /* Running Phase */
        <div className="space-y-6">
          {/* Code Editor */}
          <div className="w-full">
            <CodeEditor
              value={code}
              onChange={handleCodeChange}
              language={language}
              onLanguageChange={setLanguage}
              onRun={handleRunCode}
              onStop={handleStopExecution}
              onReset={handleResetCode}
              onCopy={handleCopyCode}
              height="500px"
              isExecuting={isExecuting}
              testInput={testInput}
              onTestInputChange={setTestInput}
              testOutput={testOutput}
              consoleOutput={consoleOutput}
              executionTime={executionTime}
              memoryUsage={memoryUsage}
              testResults={testResults}
            />
          </div>

          {/* Test Results - Below Code Editor */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Clock className="h-5 w-5" />
                Test Results
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3 mb-4">
                {testCases.map((testCase) => (
                  <div
                    key={testCase.id}
                    className={`p-3 rounded-lg border text-sm cursor-pointer transition-all hover:shadow-md ${
                      testCase.result === 'pass'
                        ? 'bg-green-50 dark:bg-green-950/20 border-green-200 dark:border-green-800 hover:bg-green-100 dark:hover:bg-green-950/30'
                        : testCase.result === 'fail'
                        ? 'bg-red-50 dark:bg-red-950/20 border-red-200 dark:border-red-800 hover:bg-red-100 dark:hover:bg-red-950/30'
                        : 'bg-muted border-muted-foreground/20 hover:bg-muted/80'
                    }`}
                    onClick={() => setCurrentTestCase(testCase)}
                  >
                    <div className="flex flex-col items-center gap-1">
                      <span className="font-medium">Test {testCase.id}</span>
                      {testCase.result === 'pass' && <CheckCircle className="h-4 w-4 text-green-600" />}
                      {testCase.result === 'fail' && <XCircle className="h-4 w-4 text-red-600" />}
                      {testCase.result === 'pending' && <div className="h-4 w-4 rounded-full border-2 border-muted-foreground/30" />}
                    </div>
                  </div>
                ))}
              </div>

              <div className="flex justify-center">
                <Button
                  onClick={runAllTestCases}
                  disabled={isExecuting}
                  className="gap-2"
                  size="lg"
                >
                  <Play className="h-4 w-4" />
                  {isExecuting ? 'Running Tests...' : 'Run All Tests'}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Problem Link Display */}
      {sessionStarted && problemLink && (
        <Card>
          <CardContent className="pt-4">
            <div className="flex items-center gap-2">
              <Link className="h-4 w-4" />
              <a
                href={problemLink}
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-600 hover:text-blue-800 underline"
              >
                {problemLink}
              </a>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Current Test Case Output */}
      {sessionStarted && currentTestCase && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">Current Test Case (#{currentTestCase.id})</CardTitle>
          </CardHeader>
          <CardContent>
            {/* Output Display */}
            {currentTestCase.actualOutput && (
              <div className="space-y-2 mb-2">
                <div className="flex items-center justify-between">
                  <Label className="text-xs font-medium text-muted-foreground">
                    Output
                  </Label>
                  {currentTestCase.expectedOutput.trim() && (
                    <Button
                      onClick={() => setShowComparison(!showComparison)}
                      variant="outline"
                      size="sm"
                      className="h-6 text-xs"
                    >
                      {showComparison ? 'Hide Comparison' : 'Compare Output'}
                    </Button>
                  )}
                </div>

                {/* Simple Output Display */}
                {!showComparison && (
                  <div className={`p-3 border rounded text-sm font-mono whitespace-pre-wrap min-h-[80px] max-h-[150px] overflow-y-auto ${
                    currentTestCase.result === 'pass'
                      ? 'bg-green-50 dark:bg-green-950/20 border-green-200 dark:border-green-800 text-green-800 dark:text-green-200'
                      : currentTestCase.result === 'fail'
                      ? 'bg-red-50 dark:bg-red-950/20 border-red-200 dark:border-red-800 text-red-800 dark:text-red-200'
                      : 'bg-muted'
                  }`}>
                    {currentTestCase.actualOutput.trim() || 'No output'}
                  </div>
                )}

                {/* Detailed Comparison View */}
                {showComparison && currentTestCase.expectedOutput.trim() && (
                  <div className="grid grid-cols-2 gap-2">
                    <div>
                      <Label className="text-xs font-medium text-muted-foreground mb-1 block">
                        Expected Output
                      </Label>
                      <div className="p-2 bg-green-50 dark:bg-green-950/20 border border-green-200 dark:border-green-800 rounded text-xs font-mono whitespace-pre-wrap min-h-[60px] max-h-[100px] overflow-y-auto">
                        {currentTestCase.expectedOutput.trim()}
                      </div>
                    </div>
                    <div>
                      <Label className="text-xs font-medium text-muted-foreground mb-1 block">
                        Your Output
                      </Label>
                      <div className={`p-2 border rounded text-xs font-mono whitespace-pre-wrap min-h-[60px] max-h-[100px] overflow-y-auto ${
                        currentTestCase.result === 'pass'
                          ? 'bg-green-50 dark:bg-green-950/20 border-green-200 dark:border-green-800'
                          : 'bg-red-50 dark:bg-red-950/20 border-red-200 dark:border-red-800'
                      }`}>
                        {currentTestCase.actualOutput.trim() || 'No output'}
                      </div>
                    </div>
                  </div>
                )}

                {/* Difference Details */}
                {showComparison && currentTestCase.result === 'fail' && currentTestCase.expectedOutput.trim() && (
                  <div className="text-xs text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-950/20 p-2 rounded border border-red-200 dark:border-red-800">
                    <strong>Difference:</strong>
                    <div className="mt-1 font-mono whitespace-pre-wrap">
                      {(() => {
                        const expected = currentTestCase.expectedOutput.trim();
                        const actual = currentTestCase.actualOutput?.trim() || '';

                        if (expected === actual) {
                          return "Outputs match exactly";
                        }

                        // Simple diff: show line by line differences
                        const expectedLines = expected.split('\n');
                        const actualLines = actual.split('\n');
                        const maxLines = Math.max(expectedLines.length, actualLines.length);
                        const differences: string[] = [];

                        for (let i = 0; i < maxLines; i++) {
                          const expLine = expectedLines[i] || '';
                          const actLine = actualLines[i] || '';

                          if (expLine !== actLine) {
                            if (expLine && !actLine) {
                              differences.push(`Line ${i + 1}: Missing output (expected: "${expLine}")`);
                            } else if (!expLine && actLine) {
                              differences.push(`Line ${i + 1}: Extra output (got: "${actLine}")`);
                            } else {
                              differences.push(`Line ${i + 1}: Expected "${expLine}", got "${actLine}"`);
                            }
                          }
                        }

                        return differences.length > 0 ? differences.join('\n') : 'Outputs differ but no specific differences found';
                      })()}
                    </div>
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );
};

export default PracticeSession;
